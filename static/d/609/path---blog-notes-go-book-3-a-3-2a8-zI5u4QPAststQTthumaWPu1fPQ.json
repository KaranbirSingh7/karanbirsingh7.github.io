{"data":{"markdownRemark":{"html":"<p>I've been writing Go for the past year while working on the\n<a href=\"https://www.cloudfoundry.org/\">Cloud Foundry</a> platform.\nTo get started using the language, I ran through a few of the resources on the\nGolang homepage such as <a href=\"https://tour.golang.org\">A Tour of Go</a> and <a href=\"https://golang.org/doc/effective_go.html\">Effective Go</a>.\nI also read through the excellent <a href=\"https://gobyexample.com/\">Go by Example</a> site which shows annotated example programs.\nThe fact that you can be fairly proficient in the language after an afternoon of reading shows how simple and well-designed the language is.</p>\n<p>I picked up <a href=\"http://www.gopl.io/\">The Go Programming Language</a> to get a better understanding of the finer points of the language.\nThis post is compiled from my notes as I read through this book.\nPull quotes are taken from the text, see citation 1.</p>\n<h2 id=\"chapter-1-tutorial\"><a href=\"#chapter-1-tutorial\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 1: Tutorial</h2>\n<blockquote>\n<p>When you're learning a new language, there's a natural tendency to write code as you would have written it in a language you already know. - pg 1</p>\n</blockquote>\n<p>I was definitely guilty of this when I was first learning Go.\nOn the plus side, a combination of limited language features and opinionated tools (e.g. go fmt) helps to quickly build a sense of what is \"idiomatic\" in Go.</p>\n<hr>\n<p>I liked the examples chosen in the first chapter, such as recreating the <code>uniq</code> unix utility in Go (pg 11).\nIt's a toy example that's actually useful and feels like a \"real\" program (reads from stdin or passed file name as arguments).\nThe examples are also rooted in systems programming which is one of Go's strongest areas.</p>\n<hr>\n<p>Another example created an animated GIF by overlaying sine waves (pg 13).\nI haven't had a chance to use the <code>image</code> packages in Go, so it was neat to see it in action.\nThat said, the Ubuntu image viewer threw an error when I tried to open the GIF.\nThere's an open <a href=\"https://github.com/golang/go/issues/13746\">issue</a> indicating it might be fixed in Golang 1.7.\nOh well, the GIF displays without issue in Chrome or Firefox.</p>\n<hr>\n<p>I had not seen the <a href=\"https://golang.org/pkg/io/ioutil/#pkg-variables\">ioutil.Discard</a> utility before (pg 18), basically a writer to <code>/dev/null</code>.\nWould be useful when writing tests rather than initializing an empty Buffer.</p>\n<hr>\n<p>Exercise 1.11 (pg 19) asks the reader to consider what would happen if a site fails to respond when <code>http.Get</code> is called.\nI've been bitten by this before, the default HTTP client does not have a timeout configured meaning the call will block forever.\nThis is almost certainly not what you want in your production code.\nAlways construct your own <code>http.Client</code> with a reasonable timeout in your production code.</p>\n<hr>\n<p>One of the things that got me excited to learn Go was its \"Hello world\" web server example (pg 19-20).\nBeing able to spin up a functional web server in a few lines of code with only standard libs starts things off on the right foot.</p>\n<hr>\n<p>The first chapter sprints through examples ranging from \"Hello world\", image generation, and concurrently fetching URLs in 20 pages.\nThe target audience for this book seems to be at least intermediate developers that have experience from other similar languages to draw from.\nWhile this makes it a quick read for more experienced developers, beginner students might have trouble with the pacing.</p>\n<h2 id=\"chapter-2-program-structure\"><a href=\"#chapter-2-program-structure\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 2: Program Structure</h2>\n<p>I like the authors' style tip to type acronyms in the same case, preferring <code>escapeHTML</code> over <code>escapeHtml</code> (pg 28).\nI've used both styles in the past, but capitalizing acronyms more closely matches how they're typed outside of code.</p>\n<hr>\n<blockquote>\n<p>in Go there is no such thing as an uninitialized variable - pg 30</p>\n</blockquote>\n<p>I appreciate the consistent experience this provides.\nFor example incrementing a map value can be written as:</p>\n<pre><code>someMap[key]++\n</code></pre>\n<p>instead of:</p>\n<pre><code>if someMap[key] == nil {\n  someMap[key] = 0\n}\nsomeMap[key]++\n</code></pre>\n<hr>\n<p>When I initially read the paragraph describing short variable declarations (pg 30), I was disappointed the authors didn't mention the danger of accidentally shadowing variables.\nFor example, the following declares a new local variable <code>someFile</code> that shadows the package level variable of the same name, an easy mistake to make:</p>\n<pre><code>var someFile string\n\nfunc processFile() {\n  someFile, err := os.Open(\"/path/to/file\")\n  ...\n}\n</code></pre>\n<p>Instead you can declare <code>err</code> separately and use normal assignment to avoid shadowing:</p>\n<pre><code>var someFile string\n\nfunc processFile() {\n  var err error\n  someFile, err = os.Open(\"/path/to/file\")\n  ...\n}\n</code></pre>\n<p>However, the authors loop back to point common mistake later in the chapter (pg 49).\nNice catch!</p>\n<hr>\n<p>I like the idea of Go's type aliases to make the code more readable and type safe.\nThe authors use temperature types as an example (pg 39):</p>\n<pre><code>type Celsius float64\ntype Fahrenheit float64\n</code></pre>\n<p>So far I've not used this feature much in my own code, definitely something to do more often.</p>\n<hr>\n<blockquote>\n<p>It is an error to import a package and then not refer to it - pg 43</p>\n</blockquote>\n<p>I love the design philosophy that code with objectively poor style should be a compiler error rather than a warning.\nLittle features like this help keep the code tidy without reliance on linters and vetters (not to say that <code>golint</code> and <code>go vet</code> aren't still useful).</p>\n<hr>\n<p>I was surprised to find out about the <code>init()</code> function (pg 44) as I haven't seen it used in the code bases I've seen.\nYou can specify any number of <code>func init() {...}</code> methods in a package and they will be run automatically when the program starts.\n<a href=\"https://golang.org/doc/effective_go.html#init\">Effective Go</a> mentions that it can be useful for verifying pre-conditions like whether an environment variable is set.</p>\n<h2 id=\"chapter-3-basic-data-types\"><a href=\"#chapter-3-basic-data-types\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 3: Basic Data types</h2>\n<p>This chapter gave several examples of more advanced usage of the <code>fmt</code> package.\nThese include using <code>fmt.Printf(\"%08b\\n\", x)</code> to print a <code>uint8</code> with padding zeros up to a length of 8 (pg 54) and\nprinting a right-aligned set of numbers with <code>fmt.Printf(\"x = %8.3f\\n\", x)</code> to print an 8 character field with 3 digits of precision (pg 57).\nThe next CLI I work on is getting some additional pretty printing.</p>\n<hr>\n<p>The authors offered a lovely explanation for a question I never thought to ask:\nwhy do functions that always return a non-negative result like <code>len()</code> usually return an <code>int</code> instead of <code>uint</code>?\nTheir example demonstrates a subtle overflow error that could be encountered when dealing with a <code>uint</code> (pg 54):</p>\n<pre><code>medals := []string{\"gold\", \"silver\", \"bronze\"}\nfor i := len(medals) - 1; i >= 0; i-- {\n  fmt.Println(medals[i])\n}\n</code></pre>\n<p>In this example, on the fourth iteration <code>i</code> would jump from zero to the max <code>uint</code> value resulting in an index out of bounds error.\nThe authors described this error as \"calamitous\", which is a word I'd like to work into an email sometime soon.</p>\n<hr>\n<p>The authors included two wonderful math based examples to illustrate the type system:\ngenerating a 3D sine wave mesh in SVG (pg 58) and an image of the Mandelbrot set (pg 62).\nMakes me want to brush up on my math skills a bit.\nAlso shout out to this <a href=\"https://www.youtube.com/watch?v=NGMRB4O922I\">Numberphile video</a> for teaching me what a Mandelbrot set is.</p>\n<hr>\n<p>Ironically my favorite part of this chapter was only tangentially related to Go.\nThe authors include a concise and informative explanation of the relationship between\nASCII, Unicode, and UTF-8 (pg 67).\nI've not yet worked on a project that had non-ASCII character encoding as a requirement,\ndefinitely something I need to read up on.</p>\n<p>For example, I would have thought that <code>len(someString)</code> was an okay thing to do, not so when Unicode is involved.\nCalling <code>len(someUTFString)</code> will give you the length of the string in bytes, but some characters may take up more that one byte.\nInstead you can call <code>utf8.RunCountInString(s)</code> or use <code>range</code> which automatically does the UTF-8 conversion (pg 69, 70).</p>\n<hr>\n<p>Small nitpick, but I wouldn't expect a <code>basename</code> function to remove the file extension (pg 72).\nThat is all, carry on.</p>\n<hr>\n<p>I'm glad I read the section on using <code>iota</code> to generate enums (pg 77).\nThis keyword had alway felt a little magic to me, so it's nice to understand how to works and\nhow it can be extended to more complex implementations like generating powers of 1024 (pg 78).</p>\n<h2 id=\"chapter-4-composite-types\"><a href=\"#chapter-4-composite-types\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 4: Composite types</h2>\n<p>Clear explanation of the relationship between slices and arrays (pg 84).\nNot only does a slice abstract away growing the underlying array,\nit also allows multiple slices to share the same underlying array.</p>\n<hr>\n<p>As with many structures in Go, a <code>nil</code> slice is equivalent to an empty slice (pg 87).\nGood advice to make your zero values useful.</p>\n<hr>\n<p>I appreciate how easy it is to compare objects for equality in Go (pg 104) as\ncompared to languages like Java which mixes <code>==</code> and <code>.Equals()</code> for even simple objects.</p>\n<hr>\n<p>Another useful JSON tag is '-' which omits the field from serialization (pg 108).\nAlso, if you're generating a JSON string you'll always want to use tags to remove capitalization.</p>\n<hr>\n<p>Nicely formatted program output on pg 112.\nGood reminder that attention to detail matters :)</p>\n<h2 id=\"chapter-5-functions\"><a href=\"#chapter-5-functions\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 5: Functions</h2>\n<p>One of the features I miss from other languages is default parameters (pg 120).\nIn a language like Java, method overloading provides a decent workaround.\nBut in Go, the only workaround I've seen is to \"abuse\" var-args to allow arguments to be omitted.</p>\n<hr>\n<p>Nice, succinct explanation of how Go is <em>pass by value</em> (pg 120).\nFunctions always receive a copy of the argument, but if that argument is a\nreference type (e.g. pointer, slice, map) the function might modify the contents of that reference.</p>\n<hr>\n<p>The authors hint at it, but for the sake of readability I usually only use multiple return\nvalues when the second value is an error or a boolean (pg 125).\nI've seen code that uses multi-return values as a convenience with other variable types,\nand it always feels unexpected.</p>\n<p>I also liked the explanation that a boolean as a second return value (typically named <em>ok</em>) should be used for methods\nthat have only one possible failure mode, such as a cast (wrong type) or lookup (key not found) (pg 128).</p>\n<hr>\n<p>I really don't like named returned values, makes it harder to follow a function's dataflow (pg 127).\nI've heard the argument that it makes it more clear <em>what</em> the function is returning, but\nif it's not clear already, the function is probably poorly named.</p>\n<hr>\n<p>Nice, concise example showing retries with a timeout and exponential back-off (pg 130).</p>\n<pre><code>deadline := time.Now().Add(timeout)\nfor tries := 0; time.Now().Before(deadline); tries++ {\n  ...\n  time.Sleep(time.Second &#x3C;&#x3C; uint(tries)) // exponential back-off\n}\n</code></pre>\n<hr>\n<p>I've been bitten by attempting to capture an iteration value in the past (pg 141).\nIn this example, the variable <code>dir</code> represents a storage location for a value, not\nthe value itself.\nEach iteration through the loop reuses the same <code>dir</code> variable, so the <code>os.RemoveAll</code> call\nwill attempt to remove only the last assigned value of <code>dir</code>.\nThe fix is to redeclare the iteration variable inside the loop: <code>dir := dir</code>.</p>\n<pre><code>for _, dir := range tempDirs {\n  ...\n  rmdirs = append(rmdirs), func() {\n    os.RemoveAll(dir) // BAD: removes the last dir `len(tempDirs)` times\n  })\n}\n</code></pre>\n<hr>\n<p>Big fan of the <code>defer</code> keyword (pg 146).\nThe closeness of \"Open()\" and \"defer Close()\" calls allows programmers to visually pattern match.\nA missing <code>defer</code> \"looks wrong\", while a missing \"Close()\" at the end of a long function is easy to forget.</p>\n<hr>\n<p>The <code>trace</code> function is a clever one-liner to print timing info, totally using this (pg 146):</p>\n<pre><code>defer trace(\"bigSlowOperation\")()\n</code></pre>\n<pre><code>func trace(msg string) func() {\n  start := time.Now()\n  log.Printf(\"enter %s\", msg)\n  return func() { log.Printf(\"exit %s (%s)\", msg, time.Since(start)) }\n}\n</code></pre>\n<h2 id=\"chapter-6-methods\"><a href=\"#chapter-6-methods\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 6: Methods</h2>\n<p>The authors lay out a nice convention: If any method needs a pointer receiver, then all methods on that struct\nshould have a pointer receiver (pg 158).\nMakes it immediately obvious whether you should pass a pointer around vs a value.</p>\n<hr>\n<p>Nice example of building a set using a bit vector (pg 167), reminds me of a few interviews I've had...</p>\n<hr>\n<p>Kudos again to the language designers. Capitalize methods to make them public, super simple! (pg 168)</p>\n<h2 id=\"chapter-7-interfaces\"><a href=\"#chapter-7-interfaces\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 7: Interfaces</h2>\n<blockquote>\n<p>what makes Go's interfaces so distinctive is that they are <em>satisfied implicitly</em>. - pg 171</p>\n</blockquote>\n<p>I've found this feature helpful for testing via dependency injection.\nIf I want to inject a struct from a library that doesn't have a corresponding interface,\nI can simply create my own interfaces which that library object implicitly satisfies.</p>\n<hr>\n<p>The authors give a nice tip for ensuring your concrete class implements a given interface.\nAdd an assignment from your concrete class to an unused variable that has the desired interface type (pg 177):</p>\n<pre><code>package bytes\n\n// ensure Buffer satisfies io.Writer\nvar _ io.Writer = new(bytes.Buffer)\n\ntype Buffer struct{\n  ...\n}\n</code></pre>\n<hr>\n<blockquote>\n<p>A nil interface value, which contains no value at all,\nis not the same as an interface value containing a pointer that happens to be nil - pg 184</p>\n</blockquote>\n<p>I've been bitten by this \"subtle trap\" as the authors describe it.\nHere's the authors' example (pg 185):</p>\n<pre><code>const debug = true\n\nfunc main() {\n  var buf *bytes.Buffer\n  if debug {\n    buf = new(bytes.Buffer)\n  }\n  f(buf)\n  if debug {\n    ...\n  }\n}\n\nfunc f(out io.Writer) {\n  if out != nil {\n    out.Write([]byte(\"done!\\n\")) // possible nil pointer panic\n  }\n}\n</code></pre>\n<p>In Go, interfaces are composed of two parts: the <em>dynamic type</em> and the <em>dynamic value</em>.\nWhile <code>out</code> in this example might have a value of <code>nil</code>, its type is <code>*bytes.Buffer</code>.\nSince at least one of these parts is non-nil, <code>out != nil</code> is true.\nThe fix in this case is to declare <code>buf</code> with an interface type (<code>var buf io.Writer</code>) so\nthat the dynamic type is <code>nil</code> until an assignment occurs.</p>\n<hr>\n<p><code>tabwriter</code> is another nice formatting package I'll have to check out (pg 188).\nThis package prints neatly formatted tables with rows and columns.</p>\n<hr>\n<p>I feel like the \"hello, world\" example for most modern programming languages\nshould now be an HTTP server instead of printing to a terminal (pg 191).\nThe ease of spinning up a server in Go in so few lines using only standard libs\nwas what got me excited to initially learn Go.</p>\n<hr>\n<p>Always use <code>io.WriteString</code> to write a string to an <code>io.Writer</code>.\nAnother nice optimization from the authors (pg 209).</p>\n<hr>\n<blockquote>\n<p>Interfaces are only needed when there are two or more concrete types that\nmust be dealt with in a uniform way. - pg 216</p>\n</blockquote>\n<p>As I mentioned earlier, I disagree with this statement when dependency injection is involved.\nI've found myself creating interfaces that were implemented by a single struct, then\ngenerating a fake implementation from that interface using something like\n<a href=\"https://github.com/maxbrunsfeld/counterfeiter\">counterfeiter</a>.</p>\n<h2 id=\"chapter-8-goroutines-and-channels\"><a href=\"#chapter-8-goroutines-and-channels\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 8: Goroutines and channels</h2>\n<p>The authors give definitions to two styles of concurrent programming:\nCommunicating Sequential Processes (CSP) and Shared Memory Multithreading (pg 217).\nCSP involves passing messages between multiple independent processes, but variables are typically\nlocal to each process. Channels plus goroutines are an example of this style.\nShared memory multithreading involves multiple concurrent threads accessing shared variables.\nThis style makes use of locks and atomic structures.</p>\n<hr>\n<blockquote>\n<p>when we say <em>x</em> happens before <em>y</em>, we don't mean merely that <em>x</em> occurs earlier in time\nthan <em>y</em>; we mean that it is guaranteed to do so - pg 226</p>\n</blockquote>\n<p>Explanations similar to this first helped me to understand concurrent programming.\n\"I ran it on my laptop and everything happened in the right order\" is not good enough\nfor parallel programming.</p>\n<hr>\n<p>My biggest takeaway from this chapter is to be careful to avoid goroutine leaks (pg 233).\nThese can occur when a function exits, but one or more goroutines are stuck trying to send or\nreceive on a channel.\nThese goroutines cannot be garbage collected in this state, a gouroutine leak.</p>\n<p>The authors give a couple suggestions to avoid leaks, including\nusing buffered channels if the know the number of items in advance or using a WaitGroup (pg 237).</p>\n<hr>\n<p>We hit this exact bug with <code>time.Tick</code> leaking goroutines on a past project (pg 246).\nThe server have very low CPU usage for about three days, then quickly spiked to 100%.\nWe weren't cleaning up <code>time.Tick</code> correctly, and after three days the goroutine leaks\ncaused the server to crash.\nCreating a new timer and explicitly stopping it on exit fixed things up.</p>\n<hr>\n<p>Another good tip, always call <code>waitGroup.Add</code> outside the goroutine that will call <code>waitGroup.Done</code> (pg 238).\nThis ensures that all the <code>Add</code> calls are executed before the <code>waitGroup.Wait</code> call is executed.</p>\n<h2 id=\"chapter-9-concurrency-with-shared-variables\"><a href=\"#chapter-9-concurrency-with-shared-variables\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 9: Concurrency with shared variables</h2>\n<p>This chapter provides a well-written explanation of common concurrency gotchas,\nhow to use mutexes to combat them, and plenty of code examples.\nGood chapter to bookmark to check your work at a later date.</p>\n<hr>\n<p>As with <code>file.Open</code> followed by <code>defer file.Close</code>, <code>mutex.Lock</code> followed by <code>mutex.Unlock</code>\nprovides a nice visual pattern that ensures developers don't forget to release a lock (pg 264).</p>\n<hr>\n<p>I've seen codebases that explicitly name methods to indicate they are unsafe for concurrent\naccess, e.g. <code>depositUnsafe</code>.\nThis indicates to that it is the caller's responsibility to acquire any relevant locks.</p>\n<hr>\n<blockquote>\n<p>intuitions about concurrency are not to be trusted! - pg 269</p>\n</blockquote>\n<p>Good reminder to be diligent, ensure all variable access happens in a concurrently safe way.\nAttempting to convince yourself that you don't need to bother will probably end in sadness.</p>\n<hr>\n<p>The <code>sync.Once</code> method provides a clean mechanism for a one-time lazy initialization that\nis safe for concurrent access (pg 270).</p>\n<hr>\n<p><code>go test -race</code> is a great low-cost way of detecting race conditions (pg 272).\nI make sure to run this flag as part of CI on any Go project.</p>\n<hr>\n<p>The authors share an example of a non-blocking cache for HTTP requests (pg 277).\nThe implementation is a bit tricky to get exactly correct, but the authors' do\na fine job of explaining their work.</p>\n<h2 id=\"chapter-10-package-and-the-go-tools\"><a href=\"#chapter-10-package-and-the-go-tools\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 10: Package and the Go tools</h2>\n<p>Section 10.6, Packages and Naming, had several tips for manageable package names (pg 289).\nSpecifically, I like the advice to avoid package names that \"stutter\".\nFor example, prefer <code>strings.NewReader</code> over <code>strings.NewStringReader</code> as the package name\nalready hints that the Reader should be used with objects of type <code>string</code>.</p>\n<hr>\n<blockquote>\n<p>An internal package may be imported only by another package that is inside the tree\nrooted at the parent of the <code>internal</code> directory - pg 298</p>\n</blockquote>\n<p>I didn't realize internal packages, a package with a path segment named <code>internal</code>,\nwas more than a conversion and is actually enforced by the compiler.</p>\n<hr>\n<p>I wish the authors would have touched on package management tools a bit in this chapter.\nWhile the addition of <code>vendor</code> imports helps, there still doesn't seem to be a de-facto\npackage manager for Golang projects yet.\nSome use tools like Godep or Glide, some do <code>git clone</code> plus <code>git add</code> in vendor,\nwhile others just roll custom dependency management scripts.\nThe Go creators were so opinionated about many of the language features, so\nbuilt-in dependency management seems strangely omitted.</p>\n<h2 id=\"chapter-11-testing\"><a href=\"#chapter-11-testing\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 11: testing</h2>\n<blockquote>\n<p>In practice, writing test code is not much different from writing the original program itself - pg 302</p>\n</blockquote>\n<p>Like production code, tests have inputs and outputs, must be maintained, and must be read by others.\nI've seen a huge amount of copy-paste tests where the author didn't seem to mind\nthe increased maintenance costs because they were \"just tests\", tisk tisk.</p>\n<hr>\n<p>Although the authors advocate for the minimal testing approach provided by <code>go test</code>,\nI'm a big fan of <a href=\"http://onsi.github.io/ginkgo/\">Ginkgo</a> and its matcher library\n<a href=\"http://onsi.github.io/gomega/\">Gomega</a>.\nGinkgo is a BDD (Behavior Driven Development) testing framework similar to Ruby's RSpec.\nThe BDD style maintains an emphasis on readability and using the same framework across\ndifferent projects keeps tests looking consistent across different Golang codebases.</p>\n<hr>\n<blockquote>\n<p>The author of a test should strive to help the programmer who must diagnose a test failure - pg 307</p>\n</blockquote>\n<p>When writing expectations in tests, I try to add a helpful text message if the failure message would\nnot be enough to diagnose the error on its own.\nHere's an example using Gomega:</p>\n<pre><code>Expect(foundItem).To(BeTrue())\n</code></pre>\n<p>This produces an unhelpful error on failure:</p>\n<pre><code>Expected\n  &#x3C;bool>: false\nto be true\n</code></pre>\n<p>To help, we can add some additional text on failure:</p>\n<pre><code>Expect(foundItem).To(BeTrue(), \"Expected to find item with ID '%s', but it does not exist\", itemID)\n</code></pre>\n<p>Much better output:</p>\n<pre><code>Expected to find item with ID 'foo', but it does not exist\nExpected\n  &#x3C;bool>: false\nto be true\n</code></pre>\n<hr>\n<blockquote>\n<p><code>const password = \"correcthorsebatterystaple\"</code></p>\n</blockquote>\n<p>Nice <a href=\"https://xkcd.com/936/\">xkcd reference</a>.</p>\n<hr>\n<p>Not of a fan of overriding package level methods as a mechanism for providing \"fake\" implementations\nduring testing (pg 313).\nI would rather use dependency injection to explicitly pass an object or function that encapsulates the\ndesired behavior, passing a real object in the production code and a fake object in the test code.\nThis pattern makes it obvious which methods are under test and which methods belong to collaborators\non which our object under test depends.</p>\n<hr>\n<p>One feature of <code>go test</code> that I was unaware of: <code>go test -bench=.</code> (pg 321).\nThis will run all test functions whose names begin with <code>Benchmark</code> and report their\nexecution times.</p>\n<p>Similarly, <code>godoc</code> is able to find tests whose names start with <code>Example</code> and\nembed these examples in the generated godoc (pg 326).\nEven better, running <code>godoc -play</code> will turn those examples into a runnable example\npowered by the Go Playground.\nSee an example <a href=\"https://golang.org/pkg/time/#Sleep\">here</a>.</p>\n<h2 id=\"chapter-12-reflection\"><a href=\"#chapter-12-reflection\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 12: Reflection</h2>\n<p>This chapter contains several detailed reflection examples that show the power of the\nGolang <code>reflection</code> library, but I only gave this chapter a quick skim.\nAs the authors suggest in the final paragraph of the chapter (pg 352),\nreflection is a dangerous tool that is easy to misuse.\nThat said, I'll definitely refer back to this chapter if I ever find an excuse to use\nreflection.</p>\n<p>The one time I've used reflection in Golang was to interact with struct tags as shown on pg 348.\nThese tags will be familiar if you've used the Golang JSON parsing library.\nI used reflection in a similar way to marshall the response from another program,\nwhich had a strange tab separated table output, into a struct.\nThe struct ended up looking a little like this:</p>\n<pre><code>type Instance struct {\n  ID string `col:\"0\", row:\"2\"`\n  Name string `col:\"1\", row:\"2\"`\n  ...\n}\n</code></pre>\n<h2 id=\"chapter-13-low-level-programming\"><a href=\"#chapter-13-low-level-programming\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chapter 13: Low-level programming</h2>\n<p>This was another chapter I only skimmed.\nIt includes examples about invoking existing C code from a Go program as well as\nusage of the aptly named <code>unsafe</code> package that lets you step around some of Go's\ntype safety mechanisms.\nAgain, the authors sum it up so well:\n\"Avoid <em>reflect</em> and <em>unsafe</em>; come back to these chapters only if you must - pg 366\".</p>\n<hr>\n<blockquote>\n<p>Meanwhile, happy Go programming. We hope you enjoy writing Go as much as we do - pg 366</p>\n</blockquote>\n<img class=\"loading-image\" src=\"/images/gopher.jpg\" alt=\"The Go gopher in aviator headgear\" width=\"100%\"/>\n<p>The Go gopher was designed by Renee French. (<a href=\"http://reneefrench.blogspot.com/\">http://reneefrench.blogspot.com/</a>)\nThe design is licensed under the Creative Commons 3.0 Attributions license.\nRead this article for more details: <a href=\"https://blog.golang.org/gopher\">https://blog.golang.org/gopher</a></p>\n<h2 id=\"citations\"><a href=\"#citations\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Citations</h2>\n<ol>\n<li>Donovan, A. A., &#x26; Kernighan, B. W. (2015). The Go programming language. Addison-Wesley.</li>\n</ol>","frontmatter":{"date":"March 13, 2016","path":"/blog/notes-go-book","title":"Notes from The Go Programming Language"}}},"pageContext":{}}